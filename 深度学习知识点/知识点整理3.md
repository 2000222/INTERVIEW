### 理解ROC
ROC曲线被称为受试者工作曲线，反映了分类器模型或者其他模型的性能。

```
       预测
       P  |  N
 真  P TP |  FN
   
 实  N FP |  TN
 ```
ROC曲线的思想是，在不同的阈值下，预测出的正类的个数、负类的个数是不同的。当阈值为0的时候，分类器就直接把所有的数据都看作是正类。这个时候混淆矩阵就变为：
```
       预测
       P  |  N
 真  P 90 |  0
   
 实  N 10 |  0
 ```
这个时候没有预测出来的负类。

那么在提高阈值的过程中，一些负类肯定是被识别出来，表现为在提升阈值的过程中FP减少的，TN增加。当阈值到达最大的时候，所有的数据都被认为是负类。在这个过程中一些性能不好的分类器，会将正类预测为负类，也就是TP减少，FP增加。我们当然是不想这样的情况出现。理想的情况下随着阈值的增加只有FP减少，TP不变，也就是随着阈值增加$ \frac{FP}{FP+TN} $减少，而$ \frac{TP}{TP+FN} $不变并且尽量接近1。

为了从这个角度评价分类器的性能，让$ \frac{FP}{FP+TN} $作为横轴，让$ \frac{TP}{TP+FN} $(召回率/灵敏度)作为纵轴，改变阈值得到点再将点连接起来构成ROC曲线。所以ROC曲线要尽量接近左上角。

### 召回率、准确率
召回率：真正的正例中有多少被预测出来了。

准确率：预测出来为正的数据中，有多少是真正的正例。

召回率和准确率最开始是在信息检索中的评价标准：
```
               预测
            P     N
真    P     TP    FN    → TP/(TP+FN) 召回率/灵敏度
实    N     FP    TN
            ↓
          TP/(TP+FP) 准确率
```
调整阈值会得到不同的召回率和准确率，将召回率作为横轴，准确率作为纵轴得到PR曲线。一般来说召回率越高准确率越低，准确率越高召回率越低。

阈值最小的时候，所有的数据都被预测为正例，此时召回率最大。随着阈值增大，一些反例被正确分类FP减少，准确率增大；但是一些正例可能被误分类为反例TP减少FN增加，召回率减小。

### 灵敏度
$ sensitive = \frac{TP}{TP + FP} $，灵敏度就是召回率。

### FROC
Free-response ROC曲线。经典的ROC曲线不能解决对一副图像上出现多个物体然后检测进行评价的实际问行评价。FROC以每个样本中的假阳性个数为x轴，y轴和ROC一样是召回率/灵敏度。所以提出了FROC，它允许对每幅图像上存在的任意多物体的情况进。

### 人脸检测heatmap
在进行物体分类(人脸识别)的时候，将最后的全连接层改为卷积层，获得的输出就是heatmap，heatmap中每个cell可以看作是对应原图中位置上属于物体(人脸)的概率，按照一定阈值进行筛选之后将每个点恢复到原始图像的尺寸可以得到一个矩形的区域就对应的是人脸的区域。

### tensorflow如何部署到移动端
1. 首先将保存的ckpt模型文件转为pb（只保留前向传播时需要的相关数据）模型。如果是pytorch的话也可以通过这样的方式来部署。[Tensorflow 模型持久化](https://blog.csdn.net/michael_yt/article/details/74737489)
2. 安卓端可以使用tensorflow mobile或者tensorflow lite。一般使用的是tensorflow mobile。在Android Studio的build.gradle 文件中添加 TensorFlow Mobile 依赖：implementation ‘org.tensorflow:tensorflow-android:+’ 然后使用gradle进行自动构建。
3. 将转换后的模型(net.pb)添加到应用程序的资源文件夹中assest/
4. 调用tensorflow inference API来进行inference。