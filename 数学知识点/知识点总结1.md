### 矩阵的秩的含义是什么？
1. 从行列式的角度解释：
将行列式进行消元，最后剩下的非零的行列式的个数就是秩的个数，也就是说这几个等式进行组合表达出了其他的式子。

2. 从几何空间的角度解释：
将矩阵中的每行看成是一个向量，这些向量分布于一个几何空间中。其中一些向量可以由其他的向量组成，即向量间具有线性相关性。消除这些共线性，将这些向量分解到相互正交的坐标轴上，最后剩下的坐标轴个数就是秩。

参考[如何理解矩阵的秩?](https://www.zhihu.com/question/21605094)

### 矩阵低秩代表了什么？
一个矩阵低秩，代表它实际上比它看起来更简单，冗余程度高。如果一个图像的特征是低秩的，那么表示这个图像很简单，比如草原的图像的特征矩阵就比草原+蒙古包的图像低秩。现实中的画质高的图像都是低秩的，如果秩高的话，可能是因为有噪点。

在图像处理中，认为图像有一些公共的模式，所有图像都由这些基本的模式组成。假如说图像是一个交叉，那么基本元素就是一个正斜线和反斜线的叠加，只要我们找到所有的基本模式（基底）就能通过基底的线性组合表达出所有的图像。

一般来说在一个图像中，基底的数量是非常少的，如果图像是一面砖墙那么它很显然是周期重复的，也就是低秩的。

**稀疏性**代表的是，任给一个图像，基底字典可能是过完备的，也就是可以使用很多不同方案的基底来表达这个图像，但是我们希望使用基底尽量少的那个方案，因为它简单。

对于一个图片来说，基底可以很容易地被理解为一个个小的像素矩阵。如果换个基底：进行傅立叶变换、余弦离散变换等就变成了另一个基底，可能有新的更好的性质。

### 如何理解矩阵的特征值？
特征值和特征向量的定义：向量v在矩阵A的作用下(v左乘A Av)，保持方向不变进行比例为λ的伸缩。这个向量就是特征向量，这个比例就是特征向量对应的特征值。
$$ A\overrightarrow{v} = \lambda \overrightarrow{v} $$

一个矩阵可以有多个特征向量和特征值。

矩阵左乘一个向量（任意向量），如果这个矩阵是方阵，那么就是对向量做旋转和拉伸的操作。将这种操作展开，也就是将矩阵进行特征值分解，$ A = P \Lambda P^{-1} $，其中$ P $矩阵中的每一列就是特征向量，他们相互正交。$ \Lambda $是特征值组成的对角矩阵，第n个特征值对应的就是$ P $中第n个列向量。

在这里，因为$ P P^{-1} $中的向量都是单位向量并且都是正交的，所以这个矩阵左乘一个向量$ \overrightarrow{v} $后对这个向量的作用是旋转、变换基底。而$ \Lambda $的作用则是进行拉伸、缩放。

也可以理解为矩阵对向量做了拉伸，但是这个拉伸是有大小、方向的。矩阵的特征向量就是拉伸的方向，特征值就是拉伸的程度。

参考[如何理解矩阵特征值](https://www.zhihu.com/question/21874816)

### 如何理解奇异值？
奇异值分解：

对矩阵进行奇异值分解得到奇异值,设A是一个m\*n矩阵 m>=n。那么对A进行奇异值分解的结果就表示为(V.T的大小是r\*n)：$ M_{m*n} = U_{m*r} \Sigma_{r*r} V_{r*n}^T $矩阵U中的列向量被称为左奇异向量，V中的行向量被成为右奇异向量，Σ是一个对角矩阵，里面的对角线上的值就是奇异值（特征值）。

如何理解奇异值参看[奇异值的物理意义是什么？](https://www.zhihu.com/question/22237507)

### 动态规划
参考[动态规划 (第1讲)](https://www.bilibili.com/video/av16544031/)

```python
def dp(time, profit):
    """
    time: list[[begin, stop]] 工作的顺序是按照结束的时间进行排序的。
    profit: list[int]
    有几件工作，这些工作的时间有重叠，每件工作的时间不同(开始结束时间不同、有重叠)、报酬也不同，现在算出怎么选择工作使得报酬最大。
    在计算最大报酬optimal的时候，倒着想首先考虑选不选最后一个工作，选了的话opt[n] = profit[n] + opt[prev(n)]，不选就是opt[n] = opt[n-1]。
    所以是opt = max(profit[n] + opt[prev(n)], opt[n-1])
    opt[n]表示到第n项工作为止的最大报酬，prev(n)表示选了第n项工作后往前推能选的最近的那个工作的编号。

    核心思想：选/不选；逆着想问题 正着写代码

    测试用例 dp([[1, 4], [3, 5], [0, 6], [4, 7], [3, 8], [5, 9], [6, 10], [8, 11]], [5, 1, 8, 4, 6, 3, 2, 4])
    结果 [5, 5, 8, 9, 9, 9, 10, 13]
    """
    opt = [0 for i in range(len(profit))]
    opt[0] = profit[0] # 表示选择第0个活动
    for i in range(1, len(profit)):
        # 循环开始之前要先把opt[1]填上去，并且把i开始置为1
        print('i: ', i, 'opt[i]: ',max(opt[i-1], opt[i]+opt[prev(time, i)]), 'prev(i): ', prev(time, i))
        opt[i] = max(opt[i-1], profit[i]+opt[prev(time, i)])
    print(opt)

def prev(time, n):
    """
    time: list[[begin, stop]]
    n: 第n项工作
    得到 选了第n项工作后，往前算的那个最近的能做的工作的索引
    """
    begin = time[n][0]
    for i in range(n-1, -1, -1):
        # 如果这个工作的结束时间在第n项工作的开始时间之前就行
        if time[i][1] <= begin:
            return i
    return -1 # opt[-1]是被初始化为0的，所以当第n个活动之前没有活动的时候就可以使用-1来表示
```